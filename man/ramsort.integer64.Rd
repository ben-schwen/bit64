% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sort64.R
\name{ramsort.integer64}
\alias{ramsort.integer64}
\alias{shellsort.integer64}
\alias{shellsortorder.integer64}
\alias{shellorder.integer64}
\alias{mergesort.integer64}
\alias{mergeorder.integer64}
\alias{mergesortorder.integer64}
\alias{quicksort.integer64}
\alias{quicksortorder.integer64}
\alias{quickorder.integer64}
\alias{radixsort.integer64}
\alias{radixsortorder.integer64}
\alias{radixorder.integer64}
\alias{ramsortorder.integer64}
\alias{ramorder.integer64}
\title{Low-level intger64 methods for in-RAM sorting and ordering}
\usage{
\method{shellsort}{integer64}(x, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)

\method{shellsortorder}{integer64}(x, i, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)

\method{shellorder}{integer64}(x, i, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)

\method{mergesort}{integer64}(x, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)

\method{mergeorder}{integer64}(x, i, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)

\method{mergesortorder}{integer64}(x, i, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)

\method{quicksort}{integer64}(
  x,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  restlevel = floor(1.5 * log2(length(x))),
  ...
)

\method{quicksortorder}{integer64}(
  x,
  i,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  restlevel = floor(1.5 * log2(length(x))),
  ...
)

\method{quickorder}{integer64}(
  x,
  i,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  restlevel = floor(1.5 * log2(length(x))),
  ...
)

\method{radixsort}{integer64}(
  x,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  radixbits = 8L,
  ...
)

\method{radixsortorder}{integer64}(
  x,
  i,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  radixbits = 8L,
  ...
)

\method{radixorder}{integer64}(
  x,
  i,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  radixbits = 8L,
  ...
)

\method{ramsort}{integer64}(
  x,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  stable = TRUE,
  optimize = c("time", "memory"),
  VERBOSE = FALSE,
  ...
)

\method{ramsortorder}{integer64}(
  x,
  i,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  stable = TRUE,
  optimize = c("time", "memory"),
  VERBOSE = FALSE,
  ...
)

\method{ramorder}{integer64}(
  x,
  i,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  stable = TRUE,
  optimize = c("time", "memory"),
  VERBOSE = FALSE,
  ...
)
}
\arguments{
\item{x}{a vector to be sorted by [ramsort.integer64()] and
[ramsortorder.integer64()], i.e. the output of  [sort.integer64()]}

\item{has.na}{boolean scalar defining whether the input vector might contain
`NA`s. If we know we don't have NAs, this may speed-up. _Note_ that you
risk a crash if there are unexpected `NA`s with `has.na=FALSE`}

\item{na.last}{boolean scalar telling ramsort whether to sort `NA`s last
or first. _Note_ that 'boolean' means that there is no third option `NA`
as in [sort()]}

\item{decreasing}{boolean scalar telling ramsort whether to sort increasing
or decreasing}

\item{...}{further arguments, passed from generics, ignored in methods}

\item{i}{integer positions to be modified by [ramorder.integer64()] and
[ramsortorder.integer64()], default is 1:n, in this case the output is
similar to [order.integer64()]}

\item{restlevel}{number of remaining recursionlevels before `quicksort`
switches from recursing to `shellsort`}

\item{radixbits}{size of radix in bits}

\item{stable}{boolean scalar defining whether stable sorting is needed.
Allowing non-stable may speed-up.}

\item{optimize}{by default ramsort optimizes for 'time' which requires more
RAM, set to 'memory' to minimize RAM requirements and sacrifice speed}

\item{VERBOSE}{cat some info about chosen method}
}
\value{
These functions return the number of `NAs` found or assumed
  during sorting
}
\description{
Fast low-level methods for sorting and ordering. The `..sortorder`
  methods do sorting and ordering at once, which requires more RAM
  than ordering but is (almost) as fast as as sorting.
}
\details{
See [bit::ramsort()]
}
\note{
Note that these methods purposely violate the functional programming
  paradigm: they are called for the side-effect of changing some of
  their arguments. The `sort`-methods change `x`, the `order`-methods
  change `i`, and the `sortoder`-methods change both `x` and `i`
}
\examples{
  x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
  x
  message("ramsort example")
  s <- clone(x)
  ramsort(s)
  message("s has been changed in-place - whether or not ramsort uses an in-place algorithm")
  s
  message("ramorder example")
  s <- clone(x)
  o <- seq_along(s)
  ramorder(s, o)
  message("o has been changed in-place - s remains unchanged")
  s
  o
  s[o]
  message("ramsortorder example")
  o <- seq_along(s)
  ramsortorder(s, o)
  message("s and o have both been changed in-place - this is much faster")
  s
  o
}
\seealso{
[bit::ramsort()] for the generic, `ramsort.default` for the methods
  provided by package {ff}, [sort.integer64()] for the sort interface and
  [sortcache()] for caching the work of sorting
}
\keyword{manip}
\keyword{programming}
