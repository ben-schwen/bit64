% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/highlevel64.R
\name{qtile}
\alias{qtile}
\alias{qtile.integer64}
\alias{quantile.integer64}
\alias{median.integer64}
\alias{mean.integer64}
\alias{summary.integer64}
\title{(Q)uan(Tile)s}
\usage{
qtile(x, probs = seq(0, 1, 0.25), ...)

\method{qtile}{integer64}(x, probs = seq(0, 1, 0.25), names = TRUE, method = NULL, ...)

\method{quantile}{integer64}(
  x,
  probs = seq(0, 1, 0.25),
  na.rm = FALSE,
  names = TRUE,
  type = 0L,
  ...
)

\method{median}{integer64}(x, na.rm = FALSE, ...)

\method{mean}{integer64}(x, na.rm = FALSE, ...)

\method{summary}{integer64}(object, ...)
}
\arguments{
\item{x}{a integer64 vector}

\item{probs}{numeric vector of probabilities with values in `[0,1]` - possibly containing `NA`s}

\item{...}{ignored}

\item{names}{logical; if `TRUE`, the result has a `names` attribute. Set to `FALSE` for speedup with many probs.}

\item{method}{NULL for automatic method selection or a suitable low-level method, see details}

\item{na.rm}{logical; if `TRUE`, any `NA` and `NaN`'s are removed from
`x` before the quantiles are computed.}

\item{type}{an integer selecting the quantile algorithm, currently only
0 is supported, see details}

\item{object}{a integer64 vector}
}
\value{
`prank` returns a numeric vector of the same length as `x`.

`qtile` returns a vector with elements from `x`
  at the relative positions specified by `probs`.
}
\description{
Function [prank.integer64()]  projects the values `[min..max]` via ranks
  `[1..n]` to `[0..1]`.
}
\details{
`qtile.ineger64` is the inverse function of 'prank.integer64' and projects
  `[0..1]` to `[min..max]`.



Functions `quantile.integer64` with `type=0` and `median.integer64` are
  convenience wrappers to `qtile`.

Function `qtile` behaves very similar to `quantile.default` with `type=1`
  in that it only returns existing values, it is mostly symmetric but it is
  using 'round' rather than 'floor'.

Note that this implies that `median.integer64` does not interpolate for even
  number of values (interpolation would create values that could not be
  represented as 64-bit integers).

This function automatically chooses from several low-level functions
  considering the size of `x` and the availability of a cache.

Suitable methods are
 - [sortqtl] (fast sorting)
 - [orderqtl] (memory saving ordering).
}
\examples{
x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
qtile(x, probs=seq(0, 1, 0.25))
quantile(x, probs=seq(0, 1, 0.25), na.rm=TRUE)
median(x, na.rm=TRUE)
summary(x)

x <- x[!is.na(x)]
stopifnot(identical(x,  unname(qtile(x, probs=prank(x)))))
}
\seealso{
[rank.integer64()] for simple ranks and [quantile()] for quantiles.
}
\keyword{univar}
