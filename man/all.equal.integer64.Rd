% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/integer64.R
\name{all.equal.integer64}
\alias{all.equal.integer64}
\title{Test if two integer64 vectors are all.equal}
\arguments{
\item{target}{a vector of 'integer64' or an object that can be coerced
with [as.integer64()]}

\item{current}{a vector of 'integer64' or an object that can be coerced
with [as.integer64()]}

\item{tolerance}{numeric > 0.  Differences smaller than `tolerance` are
not reported.  The default value is close to `1.5e-8`.}

\item{scale}{`NULL` or numeric > 0, typically of length 1 or
`length(target)`. See Details.}

\item{countEQ}{logical indicating if the `target == current` cases should
be counted when computing the mean (absolute or relative) differences.
The default, `FALSE` may seem misleading in cases where `target` and
`current` only differ in a few places; see the extensive example.}

\item{formatFUN}{a [function()] of two arguments, `err`, the relative,
absolute or scaled error, and `what`, a character string indicating the
_kind_ of error; maybe used, e.g., to format relative and absolute errors
differently.}

\item{...}{further arguments are ignored}

\item{check.attributes}{logical indicating if the [attributes()] of `target`
and `current` (other than the names) should be compared.}
}
\value{
Either ‘TRUE’ (‘NULL’ for ‘attr.all.equal’) or a vector of ‘mode’
  ‘"character"’ describing the differences between ‘target’ and
  ‘current’.
}
\description{
A utility to compare integer64 objects 'x' and 'y' testing for
  ‘near equality’, see [all.equal()].
}
\details{
In [all.equal.numeric()] the type `integer` is treated as a proper subset
  of `double` i.e. does not complain about comparing `integer` with `double`.
  Following this logic `all.equal.integer64` treats `integer` as a proper
  subset of `integer64` and does not complain about comparing `integer` with
  `integer64`. `double` also compares without warning as long as the values
  are within [lim.integer64()], if `double` are bigger `all.equal.integer64`
  complains about the `all.equal.integer64 overflow warning`. For further
  details see [all.equal()].
}
\note{
[all.equal()] only dispatches to this method if the first argument is `integer64`,
   calling [all.equal()] with a `non-integer64` first and a `integer64` second argument
   gives undefined behavior!
}
\examples{
  all.equal(as.integer64(1:10), as.integer64(0:9))
  all.equal(as.integer64(1:10), as.integer(1:10))
  all.equal(as.integer64(1:10), as.double(1:10))
  all.equal(as.integer64(1), as.double(1e300))
}
\seealso{
[all.equal()]
}
