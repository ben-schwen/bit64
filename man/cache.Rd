% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cache.R
\name{cache}
\alias{cache}
\alias{newcache}
\alias{jamcache}
\alias{setcache}
\alias{getcache}
\alias{remcache}
\alias{print.cache}
\title{Atomic Caching}
\usage{
newcache(x)

jamcache(x)

cache(x)

setcache(x, which, value)

getcache(x, which)

remcache(x)

\method{print}{cache}(x, all.names = FALSE, pattern, ...)
}
\arguments{
\item{x}{an integer64 vector (or a cache object in case of `print.cache`)}

\item{which}{A character naming the object to be retrieved from the cache or to be stored in the cache}

\item{value}{An object to be stored in the cache}

\item{all.names, pattern}{passed to [ls()] when listing the cache content}

\item{...}{ignored}
}
\value{
See details
}
\description{
Functions for caching results attached to atomic objects
}
\details{
A `cache` is an [environment] attached to an atomic object with the
  [attribute] name 'cache'. It contains at least a reference to the
  atomic object that carries the cache. This is used when accessing
  the cache to detect whether the object carrying the cache has been
  modified meanwhile.
}
\section{Functions}{
\itemize{
\item \code{newcache()}: creates a new cache referencing  `x`

\item \code{jamcache()}: forces `x` to have a cache

\item \code{cache()}: returns the cache attached to `x` if it is not
found to be outdated

\item \code{setcache()}: assigns a value into the cache of `x`

\item \code{getcache()}: gets cache value 'which' from `x`

\item \code{remcache()}: removes the cache from `x`

}}
\examples{
  x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
  y <- x
  still.identical(x,y)
  y[1] <- NA
  still.identical(x,y)
  mycache <- newcache(x)
  ls(mycache)
  mycache
  rm(mycache)
  jamcache(x)
  cache(x)
  x[1] <- NA
  cache(x)
  getcache(x, "abc")
  setcache(x, "abc", 1)
  getcache(x, "abc")
  remcache(x)
  cache(x)
}
\seealso{
[bit::still.identical()] for testing whether to symbols point to the same RAM.

Functions that get and set small cache-content automatically when a cache is present:
  [bit::na.count()], [bit::nvalid()], [bit::is.sorted()], [bit::nunique()] and
  [bit::nties()]

Setting big caches with a relevant memory footprint requires a conscious decision
  of the user: [hashcache], [sortcache], [ordercache], [sortordercache]

Functions that use big caches: [match.integer64()], [%in%.integer64],
  [duplicated.integer64()], [unique.integer64()], [unipos()], [table.integer64()],
  [as.factor.integer64()], [as.ordered.integer64()], [keypos()], [tiepos()],
  [rank.integer64()], [prank()], [qtile()], [quantile.integer64()],
  [median.integer64()], and [summary.integer64()]
}
\keyword{environment}
